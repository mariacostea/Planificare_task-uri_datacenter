# Planificare_task-uri_datacenter
Pentru implememtare am inceput cu fisierul MyDispatcher. Pentru prima politica am folosit formula din cerinta, la a-doua am folosit metoda care imi returna lungimea cozii. Am salvat intr-un minim lungimea cozii de prioritati a primului host, iar apoi am cautat in lista de hosturi care are coada cea mai scurta si am adaugat taskul in coada hostului respectiv. Pentru a-treia metoda doar am verificat tipul taskului si l-am adaugat la lista hostului corespunzator.
Pentru a-patra politica am procedat asemanator ca la cea de a-doua, dar de data aceasta am folosit metoda care returneaza cat mai are de rulat fiecare task din coada hostului. Am calculat care host are cel mai putin de rulat in continuare si am adaugat taskul in lista hostului respectiv.
In fisierul MyHost am inceput prin a-mi crea o coada de prioritati blocanta pentru a nu trebui sa folosesc alte metode de sincronizare si de comparare a prioritatilor pe parcurs. In metoda run am verificatde fi ecare data sa am taskuri in coada. Pentru taskul curent verific  daca este preeemptibil si apoi daca exista alte taskuri in coada cu prioritati mai mari pentru  ca atunci sa-l opresc pe cel curent si sa inceapa rularea taskului cu prioritate mai mare. In caz cotrar, daca nu este preemtibil si a apucat sa-si inceapa rularea ma asigur ca rularea lui nu va fi intrerupta de un alt task cu prioritate mai mare. Se da sleep(1000) si se updateaza workleft-ul, deoarece exista posibilitatea ca intre timp sa mai fi fost adaugat un task. La final se verifica daca taskul a terminat tot timpul pe care il avea de rulat. Pentru metodele getQueueSize si getWorkLeft mi-am luat o coada de priorotati, deoarece respectarea politicilor lua in considerare si task-ul care era in rulare de pe fiecare host, nu doar cele care erau in asteptare. Asa ca am adaugat in aceasta coada de fiecare data cand adaugam si in cealalta, dar stergeam taskul doar dupa ce isi termina complet rularea si nu mai avea nicio secunda de rulat.
